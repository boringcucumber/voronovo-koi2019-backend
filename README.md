# voronovo-koi2019-backend
Генерируемые примеры в приложении называются *викторинами*. Для того, чтобы создать викторину, используются 2 файла.
***
## **generator.properties**
***
Для примера возьмем первую запись из этого файла:
```java
builder.samples.sum_subtraction.natural.level_1 = default [var1]+-[var2] | var1 between 1;9 <> \
                                                                           var2 between 1;9 \
                                                | verify [var1]>=[var2] \
                                                | interval=3 4 \
                                                | javascript integer
```
Начнем с левой стороны.
*builder.samples* - префикс. Он не несёт смысловой нагрузки, но обязателен при написании, т.к. с помощью него приложение определяет, что это - вопрос викторины.
*sum_subtraction.natural.level_1* - собственно путь, по которому следует искать саму викторину. Точка обозначает вложенность, т.е. в sum_subtraction находится natural,а в нем level_1. Например, возьмем первые 6 записей из файла generator.properties (правая часть опущена за ненадобностью):
```java
builder.samples.sum_subtraction.natural.level_1 = ...
builder.samples.sum_subtraction.natural.level_2 = ...
builder.samples.sum_subtraction.natural.level_3 = ...
builder.samples.sum_subtraction.integer.level_1 = ...
builder.samples.sum_subtraction.integer.level_2 = ...
builder.samples.sum_subtraction.integer.level_3 = ...
```
Отбрасываем builder.samples (т.к. он не нужен):
```java
sum_subtraction.natural.level_1 = ...
sum_subtraction.natural.level_2 = ...
sum_subtraction.natural.level_3 = ...
sum_subtraction.integer.level_1 = ...
sum_subtraction.integer.level_2 = ...
sum_subtraction.integer.level_3 = ...
```
Видим, что sum_subtraction - единственный раздел верхнего уровня. У него, в свою очередь, есть 2 подраздела: natural и integer, у каждого по 3 уровня.
***
## **name.properties** 
***
Этот файл небольшой, нужен только для того, чтобы записывать название для разделов, которые имеются в generator.properties. Здесь каждый из разделов (builder.samples, sum_subtraction, integer, level_1, level_2, natural, ...) должен иметь своё название, которое будет отображаться в мобильном приложении. Посмотрим на две первые записи:
```java
generator.names.sum_subtraction = сложение и вычитание
generator.names.multiply_division = умножение и деление
```
*generator.names* - опять же, тот самый префикс, он просто должен быть.
```java
sum_subtraction = сложение и вычитание
multiply_division = умножение и деление
```
Тут все очевидно: слева - название, которое используется в generator.properties, справа - название на русском языке, которое отобразится в мобильном приложении.
***
## Описание логических частей генератора
***
Перейдем к правой части из generator.properties:
```java
builder.samples.sum_subtraction.natural.level_1 = default [var1]+-[var2] | var1 between 1;9 <> \
                                                                           var2 between 1;9 \
                                                | verify [var1]>=[var2] \
                                                | interval=3 4 \
                                                | javascript integer
```
Пример имеет 5 логический частей, все они разделяются знаком |. 
* Шаблон - default [var1]+-[var2]
* Предусловия - var1 between 1;9 <> \ var2 between 1;9
* Постусловия - verify [var1]>=[var2]
* Параметры генератора ответов - interval=3 4
* Параметры калькулятора - javascript integer

Знак \ используется только для переноса строк в файле, т.е. запись 
```java
var1 between 1;9 <> \ 
var2 between 1;9 \
```
то же самое, что и просто 
```java
var1 between 1;9 <> var2 between 1;9
```
Важно не забывать расставлять пробелы перед и после | и \, т.к. приложение может не распознать викторину, которую написали, и не сможет запуститься. Знак \\ используется для того, чтобы для одной викторины можно было задать несколько видов вопросов, которые будут случайным образом выбираться для создания вопроса.
### Шаблон
```java
default [var1]+-[var2]
```
Шаблон - это пример, из которого будет сформирован конечный вопрос.
Cлева - маркер, который означает какого типа шаблон. Разделять пробелом с правой частью. Всего их два (на данный момент):
* *default* - стандартный шаблон. Правая часть шаблона - это "пример", в котором будут заменяться переменные var на сгенерированные числа. Если подряд поставить знаки, то среди них выберется случайный. То есть в примере шаблон зарандомит два числа, и случайно поставит плюс или минус между ними, таким образом получится вопрос.
* *pow* - шаблон для степеней. *Все **не default** шаблоны должны быть описаны в коде*. Тут проще - правая часть означает название класса, который будет использоваться при генерации, т.е. SAME_BASE будет использовать логику класса SameBasePowTestBuilder, который сгенерит вопрос с одинаковой степенью.
### Предусловия
Предусловия - это условия генерации переменных, которые должны быть реализованы перед тем, как начнётся разбор шаблона. Разделяются они между собой <>, чтобы указать параметры генерации для нескольких переменных. Есть два варианта на выбор:
* == - переменной присваивается числовое значение, т.е. 
```java
var1 == 50
```
значит, что переменной будет присвоено значение 50.
* between - значение переменной берется из некого интервала. Синтаксис интуитивно понятный, но на всякий распишу. Указываются два числа через точку с запятой, в интервали между первым и вторым выбирается случайно число. Если использовать еще слово *and*, то выбор будет происходить уже между ДВУМЯ интервалами.
Подытожим примером:
```java
var2 == 46 <> var1 between -9;-1 and 1;9 <> var3 betwee 100;200
```
Значит, что первая переменная будет от -9 до -1, либо от 1 до 9; вторая будет равна 46, третья будет от 100 до 200.
### Постусловия
Постусловия проверяются после того, как были сгенерированы числа для переменных, и вычислен ответ для шаблона. Варианты:
* *none* - никаких постусловий, т.е. ответ и сам шаблон остаются без изменений
* *integer* - ответ должен быть целочисленным. Например для шаблона **[var2]/[var1]** было использовано деление, **var1 between 1;9 <> var2 between 10;99**. Выбираем случайно числа, **var1=6, var2=26**. Подставляем в шаблон, находим ответ **26/6=4,333...**. Ответ не целочисленный, а значит такой шаблон (26/6) будет отвергнут, генератор подберет новые числа и продолжит поиск подходящего варианта.
* *pattern* - шаблон, который будет показан пользователю, заменится новым, ответ тоже подлежит замене. Сначала идет новый шаблон, затем через пробел новый ответ. Например запись (с заранее сгенерированными **var1 = 24 и var2 = 4**)
```java
pattern [var2]x=[answer] [var1]
```
значит, что пользователь увидит на экране 4x=24, а ответом будет 4.
* *verify* - проверка, которая должна быть выполнена, чтобы сгенерированный вопрос был признан годным. Проверка производится силами калькулятора, в ответе должно быть либо true, либо false. Например, если тема - *сложение и вычитание натуральных чисел*, а ответ должен быть положительным, надо, чтобы первое число было больше второго.
```java
verify [var1]>=[var2]
```
### Параметры генератора ответов
Описывают то, каким образом будут генерироваться неправильные ответы. Берется правильный ответ, к которому по очереди применяются генераторы неправильного ответа. После пробела пишется какое-либо значение, после знака равно пишется частота (пока не реализовано).
* *interval* - самый часто используемый, от правильного ответа отнимается значение в интервале между 1 и значением., т.е. для **interval=3 4** неправильный ответ равен правильный ответ число от 1 до 4.
* *negative* - меняется знак на противоположный.
* *modify* - похож по своей работе на *pttern* у постусловия.
* 
### Калькулятор
Калькулятор - это движок, который будет использован для вычислений. На данный момент есть только один, javascript, но, если понадобится более комплексная логика вычислений, то можно написать свой и подключить его. У этого калькулятора есть 2 режима, целочисленные (javascript inreger) и вещественные (javascript double) вычисления (вещественные не тестировались).
***
## Написание своей викторины
***
Теперь, узнав все возможные параметры, попробуем разобраться в сложных генераторах, которые уже есть в приложении.
```java
builder.samples.equation.level_3 = default ([var4]-[var2])/([var1]-[var3]) | var5 between -20;-1 and 1;20 <> \
                                                                             var6 between -20;-1 and 1;20 <> \
                                                                             var1 between -20;-1 and 1;20 <> \
                                                                             var4 between -20;-1 and 1;20 <> \
                                                                             var7 == [var5]*[var6] <> \
                                                                             var3 == [var1]-[var6] <> \
                                                                             var2 == [var4]-[var7] \
                                 | integer <> pattern [var1]x+[var2]=[var3]x+[var4] [answer] \
                                 | interval=3 4 <> negative=2 \
                                 | javascript integer
```
Шаблон стандартный, [var4]-[var2])/([var1]-[var3]. Начнем сразу считать значения переменных, чтобы лучше понимать как все будет работать. Все переменные рандомятся по очереди.
```java
var5 = 10
var6 = 4
var1 = 15
var4 = 9
var7 = 10*4 = 40
var3 = 15-4 = 11
var2 = 9-40 = -31
```
Подставляем это в [var4]-[var2])/([var1]-[var3]
```java
(-9-(-31))/(15-11) = (-40)/(4) = -10
```
Есть результат вычисления **10** и шаблон с подставленными числами **(-9-(-31))/(15-11)**. Далее срабатывает постусловие *integer* (ответ целочисленный, все ок) и *pattern*, а это значит, что теперь ответ нужно заменить. Берем новый шаблон **[var1]x+[var2]=[var3]x+[var4]**, подставляем значения **15x-31=11x+9**. Это будет показано пользователю, ответ **10**. Далее генерятся неправильные ответы. Берётся интервал **4**, создаются неправильные ответы 8 11 9, два из них меняют свои знаки -8 -11 9. Пользователь видит вопрос:
```java
15x-31=11x+9
1) 10
2) -8
3) -11
4) 9
```
Возьмем самый сложный пример, который используется в неравенствах.
```java
builder.samples.inequality.level_1 = default [var1]*[var2] | var1 between -20;-1 and 1;20 <> \
                                                             var2 between -20;-1 and 1;20 <> \
                                                             var3 == Math.random()>0.5?"=":"" <> \
                                                             var4 == Math.random()>0.5?">":"<" <> \
                                                             var5 == [var2]>0?"[var4]"=="<"?"<":">":"[var4]"=="<"?">":"<" \
                                   | pattern [var2]x[var4][var3][answer] x[var5][var3][var1] <> integer \
                                   | interval=3 4 <> negative=2 <> modify=4 "x".concat(Math.random()>0.5?">":"<").concat(Math.random()>0.5?"=":"").concat("[option]".replace(/[x><=]+/,"")) \
                                   | javascript integer
```
Генерим переменные. Здесь стоит упомянуть, что движок - javascript, а там есть некоторые фишки. Здесь используется случайное выставление знака *равно* **Math.random()>0.5?"=":""** и знака *больше или меньше* **Math.random()>0.5?">":"<"**. Это называется тернарный оператор, и работает по принципу **условие ? если да : если нет** (можно комбинировать несколько тернарных, что и было использовано для var5). То есть, Math.random() выбирает случайно от **0 до 1 число**, затем проверяется условие:**число > 0.5**? если **да**, то выбирается *знак равно*, если нет - ничего (аналогично для < или >).
```java
var1 = 18
var2 = -16
var3 = 0.2>0.5, значит знак равно не учавствует
var4 = 0.7>0.5, значит выбран знак >
var5 = -16>0, значит проверяем след. тернарный оператор "[var4]"=="<"?"<":">". > не равен <, значит выбираем знак >.
```
подставляем значения в шаблон **[var1]x[var2]**=18*(-16)=-288. Ответ целочисленный (постусловие integer), заменяем *pattern* **[var2]x[var4][var3][answer] = -16x>-288**, ответ так же меняется **x[var5][var3][var1] = x<18**. Среди генераторов неправильных ответов замечен *modify*, здесь опять же используется javascript для того, чтобы вычислить неправильный ответ. Слово concat означает, что надо соединить два слова, например **"x".concat("y") = "xy"**. Вычисляем пробный неправильный ответ: 
```java
x".concat(Math.random()>0.5?">":"<").concat(Math.random()>0.5?"=":"").concat("[option]".replace(/[x><=]+/,""))
```
Сначала сгенерятся случайно знаки через Math.random().
```java
x".concat(">").concat("=").concat("[option]".replace(/[x><=]+/,""))
```
[option] Означает неправильный ответ, в котором *уже* заменено число при помощи *interval*. Слово replace означает, что определенные знаки в [option] будут заменены на другие. Таким образом, в [option] любое кол-во знаков x><= в любой комбинации будет заменено на "", то есть на ничего. Проще говоря - надо удалить все НЕ числовые элементы из [option] (за исключением минуса, если таковой есть у числа). Поэтому из неправильного ответа **x<-21** получится -21. Подставим это дальше
```java
x".concat(">").concat("=").concat("21")) -> x>=-21
```
Таким образом, получился новый неправильный ответ. В итоге пользователь увидит:
-16x>-288
1) x<18
2) x<-21
3) x>=19
4) x<=16
